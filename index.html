<!doctype html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">

    <!-- Load d3.js -->
    <script src="https://d3js.org/d3.v4.js"></script>
    <!-- specific plugin -->
    <script src="https://d3js.org/d3-contour.v1.min.js"></script>

    <title>Improved Reverse Image Search</title>
</head>

<style>
    .canvasInline {
        display: inline-block;
        float: left;
        position: absolute;

    }
    .canvasWrapper {
        display: block;
        position: relative;
        float: left;
    }

    .fixedWidth600px {
        width: 302px;
        height: 302px;
    }

    .fixedWidth400px {
        width: 402px;
        height: 402px;
    }
    .linebreak {
        margin: auto;
        align-content: center;
    }
    .frag {
        width: 126px;
        height: 126px;
    }
    canvas {
        border: 1px solid black;
    }
    .demowrap {
        text-align: left;
        display: inline-block;
    }

    .basicFullDemoWrapper {
        width: 1010px;
    }
    .equationDiv {
        padding: 10px 0;
    }
    .footer {
        margin-top: 100px;
    }
</style>



<!--<canvas style="display: none" id="imageMods" width="200" height="200"></canvas>-->

<style>
    .ct-chart {
        width: 600px;
        height: 400px;
    }
    .ct-series-b .ct-point{
        stroke: blue !important;
    }
</style>
<body>
<div style="font-size: 1em" class="container clearfix">
    <div class="clearfix linebreak">
        <div class="p-5">

            <h1 style="margin: 30px 0">Improved Reverse Image Search</h1>
            <hr>
            <h2>The Problem</h2>
            <p>
                When using major reverse image search engines, a frequently encountered problem is the inability for the algorithms to match input images if they have been cropped, stretched, rotated or scaled. This means that we have situations where a minor manipulation of the image returns no results in the Google, Bing or Tineye databases.
            </p>
            <h2>The Aim</h2>
            <p>
                We want to be able to take a cropped, rotated, skewed and/or scaled image and match it to its original, unedited image or to any variation of the image which has had a 2D Affine Transformation [insert link to wikipedia article] applied to it. We only handle 2D Affine Transformations for two reasons: 1) They have special properties which we can exploit and 2) they cover most commonly-used digital transformations which are applied to images.
            </p>
            <p>
                The algorithm we have designed allows us to quickly find image matches in a large database in either O(1) or log(n) time. Previously, we worked on this project:
                <br>https://pippy360.github.io/transformationInvariantImageSearch/ which also offered an improvement on aspects of Google, Bing and Tineye’s reverse image search but proved very slow for larger images. This previous iteration relied on finding sets of three key points to create triangles which were cross-referenced against the images in our database. The new algorithm uses a single point to define an arbitrary local feature which is subsequently cross-referenced against the images in our database.
            </p>
            <h2>The Solution</h2>
            <p>
                The first step in our solution is to pre-process the image in our database. For each image, we select n points in the image and use them to identify “key shapes”. These key shapes can be thought of as identifying features which allow us to match our input image to an image in our database.
            </p>
            <p>
                Once we have extracted our shapes, we can divide the next step into three independent problems. For the purposes of clarity, we will treat these problems sequentially but they can be approached in any order.
            </p>
            <p>
                First, we make our shape as “square” as possible<br>
                Second, we scale the image so that the key shape takes up x% of the width of 100 units.
                Finally, we compare our image against the 360 rotations in
            </p>
            <div class="text-center">
                <img src="images/pasted%20image%200.png" width="400px">
                <img src="images/pasted%20image%201.png" width="400px">
            </div>
            <p>
                We find a common transformation for the shapes (a common output shape for two input shapes that are the
                same but only have different transformations applied)
            </p>
            <figure class="text-center" style="width: 1206px; height: 322px;">
                <figcaption>
                </figcaption>
                <div>
                    <div style="height: 302px; width: 302px; display: inline-block; float: left">
                        <div class="linebreak">
                            <div class="canvasWrapper">
                                <canvas class="canvasInline" height="300" id="imageNoChanges_top" width="300"></canvas>
                                <canvas class="canvasInline" height="300" id="imageNoChanges_top_ui" style="cursor: pointer" width="300"></canvas>
                            </div>
                        </div>
                    </div>
                    <div style="height: 302px; width: 302px; display: inline-block; float: left">
                        <div class="linebreak">
                            <div class="canvasWrapper">
                                <canvas class="canvasInline" height="300" id="imageScaled_top" width="300"></canvas>
                                <canvas class="canvasInline" height="300" id="imageScaled_top_ui" width="300"></canvas>
                            </div>
                        </div>
                    </div>
                    <div id="graph2DDataViz_top" style="width: 300px; height: 300px; position: relative; float: left">
                        <div style="width: 0px; height: 0px; position: relative; top: 145px; left: 145px">
                            <div id="draggableButton_top" style="width: 20px; height: 20px; background-color: #5bb2f5; border: 1px solid #fff; border-radius: 20px; cursor: pointer"></div>
                        </div>
                    </div>
                    <div style="height: 302px; width: 302px; display: inline-block; float: left">
                        <div class="linebreak">
                            <div class="canvasWrapper">
                                <canvas class="canvasInline" height="300" id="transformedImageAndShape_top" width="300"></canvas>
                                <canvas class="canvasInline" height="300" id="transformedImageAndShape_top_ui" width="300"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </figure>
            <div style="width: 1206px; height: 200px">
                <div style="float:left; width: 300px; height: 200px;">
                    <p>Click and drag on the image above and below to edit the transformation.</p>
                </div>
                <div style="float:left; width: 300px; height: 200px;">
                    <p>(Animate this transformation) First we scale the shape up (to make it scale invariant) and center it...we also handle the rotation seperately (just talk about 360 times)</p>
                </div>
                <div id="draggableImageMatrix" style="float:left; width: 300px; height: 200px;">
                    <div>
                        <script id="topMatrix" type="math/asciimath">
                            [["_va0","_va1"],[0,1/"_va2"]]
                        </script>
                    </div>
                    <br>
                    <div>
                        <script id="bottomMatrix" type="math/asciimath">
                            [["_va3","_va4"],[0,1/"_va5"]]
                        </script>
                    </div>
                </div>
                <div style="float:left; width: 300px; height: 200px;">
                    <p>Perceptual Hash: <span id="topHashOutput">b8c385461bb9f9d733d3af832cf60b27</span></p>
                    <p>Hash Distance: <span id="hashDistOutput">0</span></p>
                    <p>Perceptual Hash: <span id="bottomHashOutput">288496df99b33f8f75a7ce4837d1b480</span></p>
                </div>
            </div>
            <figure class="text-center" style="width: 1206px; height: 322px;">
                <div>
                    <div style="height: 302px; width: 302px; display: inline-block; float: left">
                        <div class="linebreak">
                            <div class="canvasWrapper">
                                <canvas class="canvasInline" height="300" id="imageNoChanges_bottom" width="300"></canvas>
                                <canvas class="canvasInline" height="300" id="imageNoChanges_bottom_ui" style="cursor: pointer" width="300"></canvas>
                            </div>
                        </div>
                    </div>
                    <div style="height: 302px; width: 302px; display: inline-block; float: left">
                        <div class="linebreak">
                            <div class="canvasWrapper">
                                <canvas class="canvasInline" height="300" id="imageScaled_bottom" width="300"></canvas>
                                <canvas class="canvasInline" height="300" id="imageScaled_bottom_ui" width="300"></canvas>
                            </div>
                        </div>
                    </div>
                    <div id="graph2DDataViz_bottom" style="width: 300px; height: 300px; position: relative; float: left">
                        <div style="width: 0px; height: 0px; position: relative; top: 145px; left: 145px">
                            <div id="draggableButton_bottom" style="width: 20px; height: 20px; background-color: #5bb2f5; border: 1px solid #fff; border-radius: 20px; cursor: pointer"></div>
                        </div>
                    </div>
                    <div style="height: 302px; width: 302px; display: inline-block; float: left">
                        <div class="linebreak">
                            <div class="canvasWrapper">
                                <canvas class="canvasInline" height="300" id="transformedImageAndShape_bottom" width="300"></canvas>
                                <canvas class="canvasInline" height="300" id="transformedImageAndShape_bottom_ui" width="300"></canvas>
                            </div>
                        </div>
                    </div>
                </div>

                <figcaption>
                </figcaption>
            </figure>


            <h2>How do we actually do it?</h2>
            <p>
                Finding a common scale is easy, we just scale the images until the shapes both have some arbitrarily chosen area (say 1000 pixels).
            </p>
            <p>
                I haven't come up with a good way of finding a common rotation so for a temporary fix I repeat the
            algorithm 360 times changing the rotation by 1 degree each time.
            </p>
            <p>
                Finding a common transformation is more complicated and requires a more in depth explanation and some
            maths.
            </p>
            <h2>Finding a common transformation</h2>
            <p>
                Firstly we’re ONLY going to handle images that have had 2d affine transformations applied to them. So we can say for sure that each image will be a 2d affine transformed version of a matching image. Most importantly working with only 2d affine transformations makes the maths doable. So what are 2d affine transformations? they are any transformation which can be expressed with a 2x2 matrix.
                Here's an example
            </p>
            <div class="text-center">
                <script id="MathJax-Element-2" type="math/asciimath">f(a,b,c,d)=["Input Shape"]*[[a,b],[c,d]]=ubrace([[1,1],[-1,1],[-1,-1],[1,-1]])_("Input x, y coordinates")*[["_v10","_v11"],["_v12","_v13"]]=ubrace([["_v20","_v21"],["_v22","_v23"],["_v24","_v25"],["_v26","_v27"]])_("Output x, y coordinates")</script>
            </div>
            <div class="text-center">
                <div class="demowrap">
                    <div class="linebreak">
                        <div class="canvasWrapper fixedWidth400px">
                            <canvas class="canvasInline" height="400" id="basicSquareDemo" width="400"></canvas>
                            <canvas class="canvasInline" height="400" id="basicSquareDemo_ui" width="400"></canvas>
                        </div>
                    </div>
                </div>
            </div>
            <p>
                Now let's normalising the shape. By normalise the shape what we really mean is to distribute the area of the shape evenly in every direction.
                By breaking the process into steps and normalising the shape first and then handling scaling and
                rotation in later steps
            </p>
            <p>
                we can reduce the number of parameters in our transformation matrix from 4 parameters:
            </p>
            <div class="equationDiv">
                <script id="basicTransformationEquation" type="math/asciimath">
                    f(a,b,c,d) = [[a,b],[c,d]]
                </script>
            </div>
            <p>
                to 2 parameters:
            </p>
            <div class="equationDiv">
                <script id="twoParameterEquation" type="math/asciimath">
                    f(a,b) = [[a,b],[0,1/b]]
                </script>
            </div>
            <p>
                We can do this by extracting a rotation and scale matrix from our matrix
            </p>
            <div class="equationDiv">
                <script id="rotationAndScaleSplit" type="math/asciimath">
                    f(a,b,c,d) = ["rotation_matrix"]*["uniform_scale_matrix"]*[[a,b],[0,1/a]]
                </script>
            </div>
            <p>
                And then dropping the rotation and uniform scale parts of the equation (because we’re going to handle rotation and uniform scale in later steps). Now we have a matrix which represents all transformations minus uniform scale and rotation.
            </p>

            <div class="text-center">
                <script id="twoParameterEquationAgain" type="math/asciimath">f(a,b) = ["Input Shape"] * [[a,b],[0,1/b]]=f("_v90","_v91") = [[1,1],[-1,1],[-1,-1],[1,-1]]*[["_v30","_v31"],["_v32","_v33"]]=[["_v40","_v41"],["_v42","_v43"],["_v44","_v45"],["_v46","_v47"]]</script>
            </div>
            <div class="text-center">
                <div class="demowrap">
                    <div class="linebreak">
                        <div class="canvasWrapper fixedWidth400px">
                            <canvas class="canvasInline" height="400" id="basicSquareDemoRis"
                                    width="400"></canvas>
                            <canvas class="canvasInline" height="400" id="basicSquareDemoRis_ui"
                                    width="400"></canvas>
                        </div>
                    </div>
                </div>
                <p>
                    Notice how we lose the ability to change the rotation and area with changes to the input
                    parameters.
                </p>
            </div>
            
            <p>
                Now to normalise our shape:
                By normalise the shape what we really mean is we want to reduce the distance from the center of the
                shape to every point in the shape.
                First we'll start by minimising a function which gives us the sum of the squared distance* to each edge in our polygon.
            </p>
            <p>
                *we should really take the distance rather than the squared distance but taking the squared distance still gives us a good result and is much easier to differentiate later.
            </p>
            <p>
                Our function is:
            </p>
            <div class="equationDiv">
                <script id="simpleFunction" type="math/asciimath">
                    f(shape) = sumx_i^2+y_i^2
                </script>
            </div>
            <p>
                Now apply our transformation matrix to each point
            </p>
            <div class="equationDiv">
                <script id="withTransformationFunctionMatrix" type="math/asciimath">
                    ubrace([[x,y]])_("Input point")*[[a,b],[0,1/b]]=ubrace([[ax+by,y/b]])_("Output point")
                </script>
            </div>
            <p>
                and fill in the new values for x and y
            </p>
            <div class="equationDiv">
                <script id="withTransformationFunction" type="math/asciimath">
                    f(shape,a,b) = sum[(ax_i+by_i)^2+(y_i/a)^2]
                </script>
            </div>
            <p>
                now let's clean this up a little to make it easier to manipulate
            </p>
            <div class="equationDiv">
                <script id="withTransformationFunctionExpanded" type="math/asciimath">
                    f(shape,a,b) = sum[a^2x_i^2+2aby_ix_i+b^2y_i^2+1/a^2(y_i)^2]
                </script>
            </div>
            <div class="equationDiv">
                <script id="withTransformationFunctionExapanded2" type="math/asciimath">
                    f(shape,a,b) = a^2sum[x_i^2]+2ab sum[y_ix_i]+b^2sum[y_i^2]+1/a^2sum[y_i^2]
                </script>
            </div>
            <p>
                If we plot this function for our square it looks like this:
            </p>
            <div class="text-center">
                <script id="withTransformationFunctionFilled" type="math/asciimath">
                    f(shape,"_v80","_v81") = "_v82"^2*"_v88"+2*"_v83"*"_v84" *"_v810"+"_v85"^2*"_v811"+("_v89"/"_v86"^2)="_v87"
                </script>
            </div>
            <p>
                You can see from the above graph that the local minimum of this function is the values which also give
                us the most square square.
                So if we find the values of a and b which minimise this function they will be the same values of a and b
                which normalise our shape.
            </p>
            <p>
                To minimise the function first get the derivatives of the function with respect to a and b:
            </p>
            <p>
                set the derivatives to zero and solve to get the following equations for a and b
                So these are the equations for the values of a and b in the transformation matrix
            </p>
            <p>
                So we take this function from above
            </p>
            <div class="equationDiv">
                <script id="withTransforma" type="math/asciimath">
                    f(shape, a, b) = a^2sum x^2 +2ab sum yx +b^2sum y^2 +1/a^2sum[y^2]
                </script>
            </div>
            <p>
                and differentiate with respect to a and b
            </p>
            <div class="equationDiv">
                <script id="aDerivative_1" type="math/asciimath">
                    (df(shape, a,b))/(da) = 2asum[x_i^2]+2b sum[y_ix_i]-(2(sum[y_i^2])/a^3)
                </script>
            </div>
            <div class="equationDiv">
                <script id="bDerivative_1" type="math/asciimath">
                    (df(shape, a,b))/(db) = 2a sum[y_ix_i]+2bsum[y_i^2]
                </script>
            </div>
            <p>
                ...the lowest point/global minimum is when the derivatives/rate of change is 0...
             </p>
            <div class="equationDiv">
                <script id="bDerivative_15" type="math/asciimath">
                     0 = 2a sum[y_ix_i]+2bsum[y_i^2]
                </script>
            </div>
            <p>
                ...isolate b...
            </p>
            <div class="equationDiv">
                <script id="bDerivative_2" type="math/asciimath">
                    b = -(a sum[y_ix_i])/(sum[y_i^2])
                </script>
            </div>
            <p>
                ...substitute in b...
            </p>
            <div class="equationDiv">
                <script id="aDerivative_2" type="math/asciimath">
                    0 = 2asum[x_i^2]+2(-(a sum[y_ix_i])/(sum[y_i^2])) sum[y_ix_i]-(2(sum[y_i^2])/a^3)
                </script>
            </div>
            <p>
                ...isolate a...
            </p>
            <div class="equationDiv">
                <script id="aDerivative_4dfd"  type="math/asciimath">
                    a^4 = (sum[y_i^2]^2)/(sum[x_i^2]sum[y_i^2]-sum[y_ix_i]^2)
                </script>
            </div>
            <p>
                so our final 2 equations for a and b are:
            </p>
            <div class="equationDiv">
                <script id="aDerivative" type="math/asciimath">
                    a = root(4)( (sum(y_i^2)^2) / (sum(x_i^2)*sum(y_i^2) - sum(x_iy_i)^2)  )
                </script>
            </div>
            <div class="equationDiv">
                <script id="bDerivative_2_" type="math/asciimath">
                    b = -(a sum(y_ix_i))/(sum(y_i^2))
                </script>
            </div>
            <p>
                which when applied to our shape gives us a normalised shape.
            </p>
            <p>
                The cool thing about solving something analytically is that after we do all that maths we're left with a really small simple function.
                For example our answer in pseudo code is:
            </p>
            <code>
<pre>

    //FIXME: highlight this code

//Get the 2 parameters of a transformation matrix [[a,b],[0,1/a]] which will spread our input shape out evenly in all directions
//xs = the sum of the square of all the x values of all our points in our shape
//xy = the sum of the square of all the y values of all our points in our shape
//xy = the sum of the product of all the y*x values of all our points in our shape

function get_a(xs, ys, xy) {
    return sqrt(sqrt( pow(ys ,2)/(xs*ys - pow(xy, 2)) ))
}

function get_b(xs, ys, xy) {
    return get_a(xs, ys, xy) * (-xy/ys)
}
</pre>
            </code>
            <p>
                We now have an algorithm which works on a set of points. The example above have been using the edge points of the polygons but this doesn't work if the outline/shape changes slightly or if we describe the same shape but with different edges.
            </p>

            <h2>(maybe explain why we can't just use the set of finite points to describe the shape)(so we don't need a noise dealing with demo!!!!)Dealing with Noise / Going from a set of points to a full 2d shape (infinite set of points) (replace all the demos above with just points, there's no need to talk about noise it's too complicated)</h2>
            <p>
                To make our algorithm work on shapes which are very similar we need to take into account every single point in the shape.
            </p>
            <p>
                So in our equations for 'a' and 'b' we now need to calculate
                <script id="xsquaresum"  type="math/asciimath">
                    sum[y_i^2]
                </script>,
                <script id="xsq333uaresum"  type="math/asciimath">
                    sum[x_i^2]
                </script>
                and
                <script id="xsqu3434aresum"  type="math/asciimath">
                    sum[y_ix_i]
                </script>
                for all of the infinite points inside our shape.
            </p>
            <p>
                Summing up these values for an infinite number would give us an infinitely high value.
                So instead we'll compute the average values for
                <script id="xsquar3434esum"  type="math/asciimath">
                    y_i^2
                </script>,
                <script id="xsq333u3434aresum"  type="math/asciimath">
                    x_i^2
                </script>
                and
                <script id="xsqu34343434aresum"  type="math/asciimath">
                    y_ix_i
                </script>
                of all the points using integration.
            </p>
            <p>
                So our equations for 'a' and 'b' become:
            </p>
            <div class="equationDiv">
                <script id="aDerdfdsfdfsivative" type="math/asciimath">
                   a = root(4)( (sum(y_i^2)^2) / (sum(x_i^2)*sum(y_i^2) - sum(x_iy_i)^2)  )   ->    a = root(4)( ((sum(y_i^2))/n)^2 / ( (sum(x_i^2))/n*(sum(y_i^2))/n - ((sum(x_iy_i))/n)^2 )
                </script>
            </div>
            <div class="equationDiv">
                <script id="bDerdfsdffixmeivative_2_" type="math/asciimath">
                   b = -(a sum(y_ix_i))/(sum(y_i^2))
                </script>
                <script id="arrowRightBValue" type="math/asciimath">
                    ->
                </script>
                <script id="bDerdfsdffidfdfxmeivative_2_" type="math/asciimath">
                   b = -(a (sum(y_ix_i))/n)/((sum(y_i^2))/n)
                </script>
            </div>
            <p>
                To compute the values of
                <script id="bDerdffddfdsdffidfdfxmeivative_2_" type="math/asciimath">
                   (sum(y_i^2))/n
                </script>
                ,
                <script id="bDerddfdfffddfdsdffidfdfxmeivative_2_" type="math/asciimath">
                   (sum(x_i^2))/n
                </script>
                and
                <script id="bDerfdfddffddfdsdffidfdfxmeivative_2_" type="math/asciimath">
                   (sum(y_ix_i))/n
                </script>
                we will break our polygon into segments and combine the values of each segment at the end.
            </p>
            <p>
                Each segment (from one edge to another) can be expressed as a line which will fit the equation of a line:
                <script id="bDerdffddfdsdffidfdfxmeivfdsfdsfative_2_dfd" type="math/asciimath">
                   y = mx+c
                </script>
                .
                We can use integration on each of these line segments to get to get the average value of
                <script id="bDerdffddfdsdffidfdfxmeivfdsfdsfative_2_" type="math/asciimath">
                   y_i^2
                </script>
                ,
                <script id="bDerddfdfffddfdsdffidfsdfdfdfxmeivative_2_" type="math/asciimath">
                   x_i^2
                </script>
                and
                <script id="bDerfdfddffddfdsdffdfdsfdsfidfdfxmeivative_2_" type="math/asciimath">
                   y_ix_i
                </script>
                for every point under the line.
            </p>
            <img width="800px" src="./images/Screen%20Shot%202020-08-01%20at%2011.07.01%20AM.png" />
            <p>
                At any x value on our line the average value of y^2 of all the points from y = 0 straight up to the line is. p is the current point on the y axis
            </p>
            <div class="equationDiv">
                <script id="aDerivative12321" type="math/asciimath">
                    1/(mx+c)*int_0^(mx+c)p^2 dp = (mx+c)^3/(3*(mx+c)) = (mx+c)^2/(3)
                </script>
            </div>
            <p>
                So at any x point on our line that is the average value of y^2 but we want the average for every x point.
                To do this we'll create a new function where the y value of each x coordinate is the average of our
                previous function multiplied by the size of the y value of that point. Then the average value of that
                new function divided by the area of our previous function will be the average value of y^2.
            </p>
            <div class="equationDiv">
                <script id="aDere12321" type="math/asciimath">
                    (sum(y_i^2))/n = 1/3*(int_(x_1)^(x_2)(mx+c)^3dx)/(int_(x_1)^(x_2)(mx+c)dx)
                </script>
            </div>

            //update the equations on the paper
            //each vertex...to the line
            //update the equations here
            //commit and publish


            <p>
                we'll use the same logic for the average value of x*y. The average value at any x coordinate on our polygon segment
            </p>
            <div class="equationDiv">
                <script id="aDeridfsdfvative12321" type="math/asciimath">
                    1/(mx+c)*int_0^(mx+c)(x*p)dp = (x*(mx+c)^2)/(2*(mx+c)) = ((mx+c)*x)/(2)
                </script>
            </div>
            <p>
                and the average x*y value at every single x coordinate
            </p>
            <div class="equationDiv">
                <script id="aDeride43fsdfvative12321" type="math/asciimath">
                    (sum(y_ix_i))/n = 1/2*(int_(x_1)^(x_2)x*(mx+c)^2dx)/(int_(x_1)^(x_2)(mx+c)dx)
                </script>
            </div>
            <p>

            </p>
            <div class="footer">
                <hr>
                Credit to ascii math/3blue1brown/plotly/distill.pub
            </div>
        </div>
    </div>

</div>
<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="scripts/jquery.min.js"></script>
<script src="scripts/jquery-3.3.1.slim.min.js"></script>
<script src="scripts/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>
<script src="scripts/bootstrap.min.js" integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k" crossorigin="anonymous"></script>

<!-- Plotly.js -->
<script src="scripts/plotly-latest.js"></script>

<script src="scripts/shapes.js"></script>
<script src="scripts/common.js"></script>
<script src="scripts/downscale.js"></script>
<script src="scripts/drawWrappers.js"></script>
<script src="scripts/matrixMaths.js"></script>
<script src="scripts/nelderMead.js"></script>
<script src="scripts/phash.js"></script>
<script src="scripts/polygonFuncs.js"></script>
<script src="scripts/transformOperations.js"></script>

<script src="scripts/stackblur.js"></script>
<script src="scripts/math.min.js"></script>
<script src="scripts/main.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=AM_CHTML"></script>
<!--<script src="scripts/latest.js?config=AM_CHTML"></script>-->
<script src="scripts/ASCIIMathML.js" type="text/html"></script>
<script src="scripts/marvinj-0.9.js"></script>
<script src="scripts/animations.js"></script>
<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-contour.v1.min.js"></script>
<script src="https://d3js.org/d3-color.v2.min.js"></script>
<script src="https://d3js.org/d3-hsv.v0.1.min.js"></script>
<script src="https://d3js.org/d3-array.v2.min.js"></script>
<script src="https://d3js.org/d3-color.v2.min.js"></script>
<script src="https://d3js.org/d3-format.v2.min.js"></script>
<script src="https://d3js.org/d3-interpolate.v2.min.js"></script>
<script src="https://d3js.org/d3-time.v2.min.js"></script>
<script src="https://d3js.org/d3-time-format.v3.min.js"></script>
<script src="https://d3js.org/d3-scale.v3.min.js"></script>

<script src="https://code.jquery.com/jquery-1.12.4.js"></script>
<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>

<script>
    function getDataForShape_flat(inShape, axisResX, axisResY, pointStart, pointEnd, maxSumVal)
    {
        const transpt = findCentroid(inShape);
        const fixedShape = applyTransformationMatrixToAllKeypoints(inShape, getTranslateMatrix(-transpt[0], -transpt[1]));
        let dataArr = [];//new Array(axisResY*axisResX);

        let min = undefined;
        let max = undefined;
        for (let i = 0; i < axisResY; i++) {
            for (let j = 0; j < axisResX; j++) {
                let xlen = pointEnd[0] - pointStart[0];
                let ylen = pointEnd[1] - pointStart[1];
                let a = (pointStart[0]) + ((xlen/axisResX)*j);
                let b = (pointStart[1]) + ((ylen/axisResY)*i);
                let v = getSumVal(fixedShape, a, b, maxSumVal);

                if (!isFinite(v))
                    debugger;

                if (min == undefined || v < min)
                    min = v;

                if (isFinite(v) && (max == undefined || v > max))
                    max = v;

                dataArr.push(v);
            }
        }
        return {
            data: dataArr,
            min: min,
            max: max,
        }
    }

    function getDataForSquareDemo(shape, pt1, pt2, n, m, maxValue) {
        return getDataForShape_flat(shape, n, m, pt1, pt2, maxValue);
    }

    function getTransformedBoundingBox(width, height, mat) {
        const initialBoundingBox = [
            [0,0],
            [0,height],
            [width, height],
            [width,0],
        ];
        const transformedShape = applyTransformationMatrixToAllKeypoints(initialBoundingBox, mat);
        let minX, maxX, minY, maxY;
        for (let i = 0; i < transformedShape.length; i++)
        {
            if (minX == undefined || transformedShape[i][0] < minX)
                minX = transformedShape[i][0];

            if (maxX == undefined || transformedShape[i][0] > maxX)
                maxX = transformedShape[i][0];

            if (minY == undefined || transformedShape[i][1] < minY)
                minY = transformedShape[i][1];

            if (maxY == undefined || transformedShape[i][1] > maxY)
                maxY = transformedShape[i][1];
        }
        return {
            minX: minX,
            maxX: maxX,
            minY: minY,
            maxY: maxY
        }
    }

    function drawMovableImageAndShapeDemo(animatedCanvasId, a, b, img, shape, preTransform, width, height) {
        const transpt = findCentroid(shape);
        setUpSquareDemoVars("v8", 12);

        const transMat = [
            [a, b, 0],
            [0, 1.0 / a, 0],
            [0, 0, 1],
        ];

        let mat = getIdentityMatrix();
        mat = matrixMultiply(getTranslateMatrix(-transpt[0], -transpt[1]), mat)
        mat = matrixMultiply(preTransform, mat)
        mat = matrixMultiply(transMat, mat)
        mat = matrixMultiply(getTranslateMatrix(width/2, height/2), mat)

        drawImageAndShapeWithTransformation(animatedCanvasId, img, shape, mat, img.width, img.height);
        updateHashValues();
    }

    function drawGraph(id, draggableId, animatedCanvasId, noChangesId, imageScaledId, shapeContainer, initialTransform) {
        const width = $("#graph2DDataViz_top").width();
        const height = $("#graph2DDataViz_top").height();
        const pt1 = shapeContainer.pt1;
        const pt2 = shapeContainer.pt2;
        const shape = applyTransformationMatrixToAllKeypoints(shapeContainer.shape, initialTransform)
        const transpt = findCentroid(shape);
        const area = calcPolygonArea(shape);
        const img = new Image();

        function drawDraggableOutput() {
            const offset = $("#" + draggableId).offset();
            const viz = $("#"+ id +" svg");
            const svgPos = viz.offset();
            const percX = (offset.left - svgPos.left)/viz.width();
            const percY = (offset.top - svgPos.top)/viz.height();
            const xval = shapeContainer.pt1[0] + ((shapeContainer.pt2[0] - shapeContainer.pt1[0])*percX);
            const yval = shapeContainer.pt1[1] + ((shapeContainer.pt2[1] - shapeContainer.pt1[1])*percY);
            setUpSquareDemoVars("va", 6, "draggableImageMatrix");
            fillDemoVals("va", [
                [xval, yval, 1.0/xval],
                [0, 1.0/xval]
            ])

            drawMovableImageAndShapeDemo(animatedCanvasId, xval, yval, img, shapeContainer.shape, initialTransform, width, height);
        }

        $( function() {
            $("#" + draggableId ).draggable({
                drag: function () {
                    drawDraggableOutput()
                }
            });
        });

        img.onload = function () {
            const imgWidth = img.width;
            const imgHeight = img.height;

            //scale it to the canvas size
            let scale;
            let offset = [0, 0];
            const imgBounds = getTransformedBoundingBox(img.width, img.height, initialTransform);
            const transformedWidth = imgBounds.maxX - imgBounds.minX;
            const transformedHeight = imgBounds.maxY - imgBounds.minY;
            if (transformedWidth > transformedHeight) {
                scale = $("#"+noChangesId).width()/transformedWidth;
            } else {
                scale = $("#"+noChangesId).height()/transformedHeight;
            }

            let scaleMat = getIdentityMatrix();
            scaleMat = matrixMultiply(getTranslateMatrix(-imgWidth/2, -imgHeight/2), scaleMat);
            scaleMat = matrixMultiply(initialTransform, scaleMat);
            scaleMat = matrixMultiply(getScaleMatrix(scale, scale), scaleMat);
            scaleMat = matrixMultiply(getTranslateMatrix(150, 150), scaleMat);
            drawImageAndShapeWithTransformation(noChangesId, img, shapeContainer.shape, scaleMat, imgWidth, imgHeight);

            //Scale the image to a constant size and center it

            let translateMat = getTranslateMatrix(-transpt[0], -transpt[1]);
            // translateMat = matrixMultiply(getScaleMatrix(400/area, 400/area), translateMat);
            // translateMat = matrixMultiply(shapeContainer.initialTransform, translateMat);
            translateMat = matrixMultiply(getTranslateMatrix(width/2, height/2), translateMat);
            translateMat = matrixMultiply(translateMat, initialTransform);
            drawImageAndShapeWithTransformation(imageScaledId, img, shapeContainer.shape,
                translateMat, imgWidth, imgHeight);

            drawDraggableOutput();
            // drawMovableImageAndShapeDemo(animatedCanvasId, 1, 0, img, shapeContainer.shape, initialTransform, width, height);
        };
        img.src = shapeContainer.imgsrc;

        const spanx = shapeContainer.pt2[0] - shapeContainer.pt1[0];
        const pixelPerValuex = math.abs(400/spanx);
        const stepsx = 1 - shapeContainer.pt1[0];
        const left = stepsx * pixelPerValuex;

        const spany = shapeContainer.pt2[1] - shapeContainer.pt1[1];
        const pixelPerValuey = math.abs(400/spany);
        const stepsy = 0 - shapeContainer.pt1[1];
        const top = stepsy * pixelPerValuey;
        // $("#" + draggableId).css({
        //     top:  top,
        //     left: left,
        // });

        const path = d3.geoPath()
        const ret = getDataForSquareDemo(shape, pt1, pt2, width/4, height/4, shapeContainer.maxValue);
        const grid = ret.data;
        const min = ret.min;
        const max = ret.max;

        const thresholds = d3.range(1, Math.log(max), Math.log(max)/30.0).map(i => Math.pow(2, i) + (min/2))

        const contours = d3.contours()
            .size([width/4, height/4])
            .thresholds(thresholds)
            (grid)

        const color = d3.scaleSequentialLog(
            d3.extent(thresholds),
            d3.interpolateMagma
        )

        //find in document instead
        const svg = d3.select("#" + id)
            .append("svg")
            .attr("viewBox", [0, 0, width/4, height/4])
            .style("display", "block")
            .style("width", "100%");

        const g = svg.append("g");

        g.attr("fill", "none").selectAll("path")

        for (let i = 0; i < thresholds.length; i++) {
            //thresholds
            const _contour = contours[i];
            const threshold = thresholds[i]
            g.append("path")
                .attr("d", path(_contour))
                .attr("fill", color(threshold-1.9))
                .attr("stroke", "#fff")
                .attr("stroke-opacity", 0.25);
        }

        // {
        //     // draw the axis
        //     const x = d3.scaleLinear([pt1[0], pt2[0]], [0, width])
        //     const y = d3.scaleLinear([pt1[1], pt2[1]], [0, height])
        //     yAxis = g => g
        //         .attr("transform", "translate(-1,0)")
        //         .call(d3.axisRight(y))
        //         .call(g => g.select(".domain").remove())
        //         .call(g => g.selectAll(".tick").filter(d => y.domain().includes(d)).remove())
        //
        //     xAxis = g => g
        //         .attr("transform", `translate(0,${height})`)
        //         .call(d3.axisTop(x).ticks(width / height * 10))
        //         .call(g => g.select(".domain").remove())
        //         .call(g => g.selectAll(".tick").filter(d => x.domain().includes(d)).remove())
        //
        //     svg.append("g")
        //         .call(xAxis);
        //
        //     svg.append("g")
        //         .call(yAxis);
        // }
    }

    const square_shape_wrap_inner = {
        imgsrc: "images/IMG_20191024_130833.jpg",
        shape: square_shape_small,
        maxSumVal: 500000000000,
        img: null,
        pt1: [ 0.1, -1],
        pt2: [ 2,  2]
    }

    const call_of_duty_inner = {
        imgsrc: "images/IMG_20191024_130833.jpg",
        shape: call_of_duty_shape,
        maxSumVal: 50000000000000,
        img: null,
        pt1: [-0, -3],
        pt2: [ 2,  3]
    }

    const example1 = {
        common: call_of_duty_inner,
        initialTransform1: [
            [1,-2,0],
            [0,1,0],
            [0,0,1]
        ],
        initialTransform2: [
            [1,0,0],
            [0,1,0],
            [0,0,1]
        ],
    }

    function redrawVizGraphs_bottom() {
        $("#graph2DDataViz_bottom" +" svg").remove();

        let bottomTrans = matrixMultiply(example1.initialTransform2, g_visualImageDragState.bottomImageTransformationMatrix);
        drawGraph("graph2DDataViz_bottom", "draggableButton_bottom", "transformedImageAndShape_bottom", "imageNoChanges_bottom", "imageScaled_bottom", example1.common, bottomTrans);
    }

    function redrawVizGraphs_top() {
        $("#graph2DDataViz_top" +" svg").remove();

        const topTrans = matrixMultiply(example1.initialTransform1, g_visualImageDragState.topImageTransformationMatrix);
        drawGraph("graph2DDataViz_top", "draggableButton_top", "transformedImageAndShape_top", "imageNoChanges_top", "imageScaled_top", example1.common, topTrans);
    }

    window.addEventListener("DOMContentLoaded", function(event) {
        redrawVizGraphs_top();
        redrawVizGraphs_bottom();
        updateHashValues();
    });

    let updateHashValues = function () {
        const topId = "transformedImageAndShape_top";
        const bottomId = "transformedImageAndShape_bottom";

        const topHash = pHash(document.getElementById(topId));
        const bottomHash = pHash(document.getElementById(bottomId));

        const dist = distance(topHash, bottomHash)
        const topOutput = document.getElementById("topHashOutput");
        const bottomOutput = document.getElementById("bottomHashOutput");
        const hashDistOutput = document.getElementById("hashDistOutput");

        topOutput.innerHTML = binaryToHex(topHash).result;
        bottomOutput.innerHTML = binaryToHex(bottomHash).result;
        hashDistOutput.innerHTML = ""+dist;
    }

    function updateVisualTransformationMatrix(ain, bin) {
        const a = ain/100.0;
        const b = bin/100.0;

        g_visualImageDragState.currentImageTransformationMatrix[0][0] = a;
        g_visualImageDragState.currentImageTransformationMatrix[0][1] = b;
        g_visualImageDragState.currentImageTransformationMatrix[1][0] = 0;
        g_visualImageDragState.currentImageTransformationMatrix[1][1] = 1.0/a;
    }

    let g_visualImageDragState = {
        topImageTransformationMatrix: getIdentityMatrix(),
        bottomImageTransformationMatrix: getIdentityMatrix(),
        currentImageTransformationMatrix: null,
        mouseDownPosition: null
    }

    $(document).mousedown(function (e) {
        //ignore
    });

    $(document).mousemove(function (e) {
        var pageMousePosition = getCurrentPageMousePosition(e);
        if (g_visualImageDragState.currentImageTransformationMatrix != null
            && g_visualImageDragState.mouseDownPosition != null) {
            updateVisualTransformationMatrix(pageMousePosition[0] - g_visualImageDragState.mouseDownPosition[0],
                                             pageMousePosition[1] - g_visualImageDragState.mouseDownPosition[1]);
            if (g_visualImageDragState.currentImageTransformationMatrix == g_visualImageDragState.topImageTransformationMatrix) {
                redrawVizGraphs_top();
            } else if (g_visualImageDragState.currentImageTransformationMatrix == g_visualImageDragState.bottomImageTransformationMatrix) {
                redrawVizGraphs_bottom();
            }
            updateHashValues()
        }
    });

    $(document).bind( "touchmove", function (e) {
        const pageMousePosition = [
            e.originalEvent.touches[0].pageX,
            e.originalEvent.touches[0].pageY
        ];
        if (g_transformState != null && g_transformState.isMouseDownAndClickedOnCanvas) {
            e.preventDefault();
        }
        mouseMoveOnDocumentEvent(pageMousePosition);
    });

    $(document).mouseup(function (e) {
        if (g_visualImageDragState.currentImageTransformationMatrix != null
            && g_visualImageDragState.mouseDownPosition != null) {
            g_visualImageDragState.mouseDownPosition = null;
        }
    });

    $(document).bind( "touchend", function (e) {
        if (g_visualImageDragState.currentImageTransformationMatrix != null
            && g_visualImageDragState.mouseDownPosition != null) {
            g_visualImageDragState.mouseDownPosition = null;
        }
    });

    $("#" + "imageNoChanges_top_ui").mousedown(function (e) {
        e.preventDefault();
        const pageMousePosition = getCurrentPageMousePosition(e);
        g_visualImageDragState.mouseDownPosition = pageMousePosition;
        g_visualImageDragState.currentImageTransformationMatrix = g_visualImageDragState.topImageTransformationMatrix;
    });

    $("#" + "imageNoChanges_bottom_ui").mousedown(function (e) {
        e.preventDefault();
        const pageMousePosition = getCurrentPageMousePosition(e);
        g_visualImageDragState.mouseDownPosition = pageMousePosition;
        g_visualImageDragState.currentImageTransformationMatrix = g_visualImageDragState.bottomImageTransformationMatrix;
    });


</script>
</body>

